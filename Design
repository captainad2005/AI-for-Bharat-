# GOVERNMENT SCHEMES NAVIGATOR
## PART 2: TECHNICAL DESIGN DOCUMENT

---

## 1. SYSTEM ARCHITECTURE

### 1.1 High-Level Architecture Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        PRESENTATION LAYER                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   WhatsApp Bot         â”‚   SMS Gateway      â”‚   Web/Mobile App   â”‚
â”‚   (Twilio API)         â”‚   (AWS SNS)        â”‚   (React)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â†“
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚  API Gateway         â”‚
                        â”‚  (Rate limit, Auth)  â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    APPLICATION LAYER (Lambda)                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Eligibility Service   â”‚  Document Service  â”‚  Application Svc   â”‚
â”‚  - Parse input         â”‚  - Generate docs   â”‚  - Track status    â”‚
â”‚  - Match schemes       â”‚  - Validate reqs   â”‚  - Send updates    â”‚
â”‚  - Score confidence    â”‚  - Localize lang   â”‚  - Store data      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â†“
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  NLP Engine (Bedrock Claude)  â”‚
                    â”‚  - Parse conversational input â”‚
                    â”‚  - Generate Hindi responses   â”‚
                    â”‚  - Intent classification      â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DATA LAYER                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  RDS (User Data)   â”‚  DynamoDB        â”‚  S3 Storage  â”‚ Cache    â”‚
â”‚  - Users           â”‚  (Scheme DB)     â”‚  - Documents â”‚ (Redis)  â”‚
â”‚  - Applications    â”‚  - 400+ schemes  â”‚  - Templates â”‚          â”‚
â”‚  - Preferences     â”‚  - Real-time     â”‚              â”‚          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â†“
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  External Government APIs     â”‚
                    â”‚  - State portals              â”‚
                    â”‚  - Hospital networks          â”‚
                    â”‚  - Application status         â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 Component Breakdown

#### Component 1: WhatsApp Bot (Twilio Integration)
```
ARCHITECTURE:
Twilio â†’ AWS Lambda Function â†’ Bedrock API â†’ DynamoDB â†’ Response

FLOW:
1. User sends WhatsApp message to Twilio number
2. Twilio webhook triggers Lambda function
3. Lambda function:
   a. Extract message text
   b. Call Bedrock Claude to parse intent + extract entities
   c. Query DynamoDB for scheme eligibility
   d. Format response in detected language
   e. Send response back via Twilio
4. Twilio sends response to user

CODE STRUCTURE:
```python
# lambda_function.py (WhatsApp Handler)

import json
import boto3
import requests
from datetime import datetime

bedrock = boto3.client('bedrock-runtime', region_name='ap-south-1')
dynamodb = boto3.resource('dynamodb', region_name='ap-south-1')
twilio_client = ...  # Twilio initialization

def lambda_handler(event, context):
    # Parse Twilio webhook
    incoming_message = event['Body']
    phone_number = event['From']
    
    # Get user context from DynamoDB
    user = get_or_create_user(phone_number)
    
    # Call Bedrock to parse message
    parsed = parse_message_with_bedrock(incoming_message, user['language'])
    
    # Route to appropriate handler
    if parsed['intent'] == 'check_eligibility':
        response = handle_eligibility_check(parsed['entities'], user)
    elif parsed['intent'] == 'apply':
        response = handle_apply(parsed['entities'], user)
    elif parsed['intent'] == 'status':
        response = handle_status(parsed['entities'], user)
    else:
        response = "à¤•à¥ƒà¤ªà¤¯à¤¾ à¤¸à¥à¤ªà¤·à¥à¤Ÿ à¤•à¤°à¥‡à¤‚à¥¤ à¤®à¥ˆà¤‚ à¤®à¤¦à¤¦ à¤•à¤° à¤¸à¤•à¤¤à¤¾ à¤¹à¥‚à¤ à¤…à¤—à¤° à¤†à¤ª à¤¬à¤¤à¤¾à¤à¤‚ à¤•à¤¿ à¤†à¤ª à¤•à¥à¤¯à¤¾ à¤•à¤°à¤¨à¤¾ à¤šà¤¾à¤¹à¤¤à¥‡ à¤¹à¥ˆà¤‚à¥¤"
    
    # Send response via Twilio
    send_whatsapp_message(phone_number, response)
    
    return {
        'statusCode': 200,
        'body': json.dumps({'status': 'sent'})
    }

def parse_message_with_bedrock(message, language='hi'):
    """Parse user message using Claude 3 via Bedrock"""
    
    prompt = f"""
    You are a Government Schemes Assistant. Parse this message from an Indian user:
    Message: "{message}"
    Language: {language}
    
    Extract:
    1. Intent (check_eligibility, apply, status, ask_docs, find_center, etc.)
    2. Entities (income, occupation, age, family_size, state, etc.)
    3. Confidence score (0-1)
    4. Missing information needed
    
    Return JSON format.
    """
    
    response = bedrock.invoke_model(
        modelId='anthropic.claude-3-sonnet-20240229-v1:0',
        body=json.dumps({
            'anthropic_version': 'bedrock-2023-06-01',
            'max_tokens': 500,
            'messages': [
                {'role': 'user', 'content': prompt}
            ]
        })
    )
    
    result = json.loads(response['body'].read())
    return json.loads(result['content'][0]['text'])

def handle_eligibility_check(entities, user):
    """Check which schemes user is eligible for"""
    
    # Query DynamoDB for eligibility
    schemes_table = dynamodb.Table('government-schemes')
    
    eligible_schemes = []
    for scheme in schemes_table.scan()['Items']:
        if matches_eligibility_criteria(entities, scheme):
            eligible_schemes.append(scheme)
    
    # Sort by benefit amount (highest first)
    eligible_schemes.sort(
        key=lambda x: x.get('benefits', {}).get('amount', 0),
        reverse=True
    )
    
    # Format response in user's language
    response = format_eligibility_response(
        eligible_schemes,
        user['language'],
        len(eligible_schemes)
    )
    
    # Store eligibility check in user's history
    save_user_interaction(user['userId'], 'eligibility_check', {
        'input': entities,
        'results': [s['schemeId'] for s in eligible_schemes],
        'timestamp': datetime.now().isoformat()
    })
    
    return response

def format_eligibility_response(schemes, language, count):
    """Generate formatted response in user's language"""
    
    if language == 'hi':
        response = f"à¤ªà¤°à¤¿à¤£à¤¾à¤® ðŸŽ‰\n\nà¤†à¤ª {count} à¤¯à¥‹à¤œà¤¨à¤¾à¤“à¤‚ à¤•à¥‡ à¤²à¤¿à¤ à¤ªà¤¾à¤¤à¥à¤° à¤¹à¥ˆà¤‚:\n\n"
        
        for i, scheme in enumerate(schemes[:5], 1):  # Show top 5
            response += f"{i}ï¸âƒ£ {scheme['name']['hi']} (â‚¹{scheme['benefits']['amount']})\n"
            response += f"   âœ“ à¤†à¤ª à¤ªà¤¾à¤¤à¥à¤° à¤¹à¥ˆà¤‚\n"
            if scheme.get('nextSteps'):
                response += f"   à¤…à¤—à¤²à¤¾ à¤•à¤¦à¤®: {scheme['nextSteps'][0]}\n"
            response += "\n"
        
        response += "à¤•à¥à¤¯à¤¾ à¤†à¤ª à¤•à¤¿à¤¸à¥€ à¤¯à¥‹à¤œà¤¨à¤¾ à¤•à¥‡ à¤¬à¤¾à¤°à¥‡ à¤®à¥‡à¤‚ à¤”à¤° à¤œà¤¾à¤¨à¤¨à¤¾ à¤šà¤¾à¤¹à¤¤à¥‡ à¤¹à¥ˆà¤‚? 'à¤¯à¥‹à¤œà¤¨à¤¾ à¤•à¤¾ à¤¨à¤¾à¤®' à¤²à¤¿à¤–à¥‡à¤‚à¥¤"
    
    return response

def matches_eligibility_criteria(user_profile, scheme):
    """Check if user matches all scheme criteria"""
    
    criteria = scheme['eligibility']
    
    # Income check
    if criteria.get('incomeLimit'):
        if user_profile.get('income', 0) > criteria['incomeLimit']:
            return False
    
    # Occupation check
    if criteria.get('occupation'):
        if user_profile.get('occupation') not in criteria['occupation']:
            return False
    
    # Land check (for farmers)
    if criteria.get('landLimit'):
        if user_profile.get('land_hectares', 0) > criteria['landLimit']['maxHectares']:
            return False
    
    # Age check
    if criteria.get('ageMin'):
        if user_profile.get('age', 0) < criteria['ageMin']:
            return False
    
    return True
```

#### Component 2: SMS Service (AWS SNS)
```python
# sms_service.py

import boto3
from datetime import datetime, timedelta

sns = boto3.client('sns', region_name='ap-south-1')
dynamodb = boto3.resource('dynamodb', region_name='ap-south-1')

def send_sms_reminder(user_id, reminder_type):
    """Send SMS reminders to users"""
    
    users_table = dynamodb.Table('users')
    user = users_table.get_item(Key={'userId': user_id})['Item']
    
    # Check if user opted in for SMS
    if not user.get('preferences', {}).get('smsReminders'):
        return
    
    messages = {
        'eligibility_found': f"à¤¨à¤®à¤¸à¥à¤¤à¥‡! à¤¹à¤®à¤¨à¥‡ à¤ªà¤¾à¤¯à¤¾ à¤•à¤¿ à¤†à¤ª {len(user.get('eligibleSchemes', []))} à¤¯à¥‹à¤œà¤¨à¤¾à¤“à¤‚ à¤•à¥‡ à¤²à¤¿à¤ à¤ªà¤¾à¤¤à¥à¤° à¤¹à¥ˆà¤‚à¥¤ à¤…à¤§à¤¿à¤• à¤œà¤¾à¤¨à¤•à¤¾à¤°à¥€ à¤•à¥‡ à¤²à¤¿à¤: [WhatsApp link]",
        
        'deadline_approaching': "âš ï¸ à¤†à¤µà¤¶à¥à¤¯à¤•: PM à¤•à¤¿à¤¸à¤¾à¤¨ à¤†à¤µà¥‡à¤¦à¤¨ à¤•à¥€ à¤…à¤‚à¤¤à¤¿à¤® à¤¤à¤¾à¤°à¥€à¤– 31-Jan à¤¹à¥ˆà¥¤ à¤…à¤­à¥€ à¤†à¤µà¥‡à¤¦à¤¨ à¤•à¤°à¥‡à¤‚: [link]",
        
        'application_status': "à¤†à¤ªà¤•à¤¾ à¤†à¤µà¥‡à¤¦à¤¨ à¤ªà¥à¤°à¤¾à¤ªà¥à¤¤ à¤¹à¥à¤†à¥¤ à¤…à¤¨à¥à¤®à¤¾à¤¨à¤¿à¤¤ à¤¸à¥à¤µà¥€à¤•à¥ƒà¤¤à¤¿ à¤¤à¤¾à¤°à¥€à¤–: {estimated_date}à¥¤ 0522-XXXX-XXXX à¤ªà¤° à¤•à¥‰à¤² à¤•à¤°à¥‡à¤‚à¥¤"
    }
    
    message_body = messages.get(reminder_type, '')
    
    # Send SMS via SNS
    response = sns.publish(
        PhoneNumber=user['phone'],
        Message=message_body,
        MessageAttributes={
            'AWS.SNS.SMS.SenderID': {
                'DataType': 'String',
                'StringValue': 'SCHEMES'
            }
        }
    )
    
    # Log SMS sent
    logs_table = dynamodb.Table('sms-logs')
    logs_table.put_item(Item={
        'messageId': response['MessageId'],
        'userId': user_id,
        'reminderType': reminder_type,
        'sentAt': datetime.now().isoformat(),
        'status': 'sent'
    })

def schedule_reminders():
    """Background job to send scheduled reminders"""
    
    # Lambda function triggered daily at 8 AM
    users_table = dynamodb.Table('users')
    
    # Find users who checked eligibility 7 days ago but haven't applied
    response = users_table.scan(
        FilterExpression='attribute_exists(lastEligibilityCheck) AND attribute_not_exists(applicationApplied)'
    )
    
    for user in response['Items']:
        last_check = datetime.fromisoformat(user['lastEligibilityCheck'])
        if (datetime.now() - last_check).days == 7:
            send_sms_reminder(user['userId'], 'deadline_approaching')
```

#### Component 3: Scheme Database (DynamoDB)
```json
// Sample scheme in DynamoDB

{
  "schemeId": "PM-KISAN",  // Partition key
  "sortKey": "v1",         // Version control
  "name": {
    "en": "Pradhan Mantri Kisan Samman Nidhi",
    "hi": "à¤ªà¥à¤°à¤§à¤¾à¤¨ à¤®à¤‚à¤¤à¥à¤°à¥€ à¤•à¤¿à¤¸à¤¾à¤¨ à¤¸à¤®à¥à¤®à¤¾à¤¨ à¤¨à¤¿à¤§à¤¿",
    "ta": "à®ªà®¿à®°à®¤à®® à®®à®¨à¯à®¤à®¿à®°à®¿ à®•à®¿à®šà®¾à®©à¯ à®šà®®à¯à®®à®¾à®©à¯ à®¨à®¿à®¤à®¿",
    "te": "à°ªà±à°°à°§à°¾à°¨ à°®à°‚à°¤à±à°°à°¿ à°•à°¿à°¸à°¾à°¨à± à°¸à°®à±à°®à°¾à°¨à± à°¨à°¿à°§à°¿"
  },
  
  "category": "agriculture",
  "managingMinistry": "Ministry of Agriculture & Farmers Welfare",
  
  "benefits": {
    "amount": 6000,
    "currency": "INR",
    "frequency": "annual",
    "installments": 3,
    "installmentAmount": 2000
  },
  
  "eligibility": {
    "occupation": ["farmer"],
    "landLimit": {
      "maxHectares": 2
    },
    "incomeLimit": null,
    "categoryRestrictions": [],
    "stateApplicability": "all",
    "ageRestriction": null
  },
  
  "requiredDocuments": [
    {
      "documentType": "aadhar",
      "mandatory": true,
      "validFormats": ["original", "photocopy"],
      "purpose": "Identity verification"
    },
    {
      "documentType": "landDeed",
      "mandatory": true,
      "validFormats": ["7/12 extract", "village record"],
      "purpose": "Land ownership proof"
    },
    {
      "documentType": "bankAccount",
      "mandatory": true,
      "validFormats": ["passbook", "statement"],
      "purpose": "Fund transfer"
    }
  ],
  
  "applicationProcess": {
    "channels": ["online", "offline"],
    "onlinePortal": "https://pmkisan.gov.in",
    "processingTime": 15,
    "applicationDeadline": "2026-12-31"
  },
  
  "enrollmentCenters": [
    {
      "centerId": "CENTER-UP-LUC-001",
      "state": "UP",
      "district": "Lucknow",
      "block": "Malihabad",
      "location": "Block Agriculture Office",
      "address": "Malihabad, Lucknow, UP 226304",
      "phone": "0522-2671-234",
      "workingHours": "10:00-17:00",
      "workingDays": ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"],
      "officeIncharge": "à¤°à¤¾à¤œ à¤•à¥à¤®à¤¾à¤°",
      "geoCoordinates": {
        "latitude": 26.8845,
        "longitude": 80.9460
      }
    }
  ],
  
  "successMetrics": {
    "totalBeneficiaries": 90000000,
    "totalFundsDispersed": 540000000000,
    "averageBenefitPerFamily": 6000
  },
  
  "lastUpdated": "2026-01-25T10:30:00Z",
  "dataSource": "Government of India",
  "verificationStatus": "verified"
}
```

### 1.3 Data Flow Diagrams

#### Flow 1: Eligibility Check Request
```
User: "à¤®à¥ˆà¤‚ à¤•à¤¿à¤¸à¤¾à¤¨ à¤¹à¥‚à¤, â‚¹2.5 à¤²à¤¾à¤– à¤•à¤®à¤¾à¤¤à¤¾ à¤¹à¥‚à¤, 1.5 à¤¹à¥‡à¤•à¥à¤Ÿà¥‡à¤¯à¤° à¤œà¤®à¥€à¤¨ à¤¹à¥ˆ"
  â”‚
  â”œâ”€â†’ WhatsApp/Twilio
  â”‚    â””â”€â†’ Extract: message text, phone number
  â”‚
  â”œâ”€â†’ Lambda (Parse Intent)
  â”‚    â””â”€â†’ Bedrock Claude NLP
  â”‚         â””â”€â†’ Intent: "check_eligibility"
  â”‚         â””â”€â†’ Entities: {
  â”‚              occupation: "farmer",
  â”‚              income: 250000,
  â”‚              land_hectares: 1.5
  â”‚            }
  â”‚
  â”œâ”€â†’ Lambda (Eligibility Service)
  â”‚    â””â”€â†’ Query DynamoDB: SELECT * FROM schemes
  â”‚    â””â”€â†’ For each scheme: Check eligibility criteria
  â”‚    â””â”€â†’ Return: [PM-KISAN, AYUSHMAN, FASAL-BIMA]
  â”‚
  â”œâ”€â†’ Lambda (Format Response)
  â”‚    â””â”€â†’ Convert to Hindi
  â”‚    â””â”€â†’ Add emoji formatting
  â”‚    â””â”€â†’ Include next steps
  â”‚
  â””â”€â†’ Twilio Send Response
       â””â”€â†’ WhatsApp to user: "à¤†à¤ª 3 à¤¯à¥‹à¤œà¤¨à¤¾à¤“à¤‚ à¤•à¥‡ à¤²à¤¿à¤ à¤ªà¤¾à¤¤à¥à¤° à¤¹à¥ˆà¤‚..."
```

#### Flow 2: Document Checklist Generation
```
User: "PM à¤•à¤¿à¤¸à¤¾à¤¨ à¤•à¥‡ à¤²à¤¿à¤ à¤†à¤µà¤¶à¥à¤¯à¤• à¤¦à¤¸à¥à¤¤à¤¾à¤µà¥‡à¤œà¤¼?"
  â”‚
  â”œâ”€â†’ Parse intent: "ask_documents"
  â”œâ”€â†’ Extract scheme: "PM-KISAN"
  â”‚
  â”œâ”€â†’ Lambda (Document Service)
  â”‚    â””â”€â†’ Query DynamoDB: Get PM-KISAN details
  â”‚    â””â”€â†’ Extract requiredDocuments array
  â”‚    â””â”€â†’ For each document:
  â”‚         â”œâ”€ Translate to Hindi
  â”‚         â”œâ”€ Add usage tips
  â”‚         â””â”€ Suggest validation tips
  â”‚
  â”œâ”€â†’ Lambda (Format Response)
  â”‚    â””â”€â†’ Create checklist format with âœ“ boxes
  â”‚    â””â”€â†’ Add processing time
  â”‚    â””â”€â†’ Add common mistakes section
  â”‚
  â””â”€â†’ Twilio Send
       â””â”€â†’ "PM à¤•à¤¿à¤¸à¤¾à¤¨ à¤•à¥‡ à¤²à¤¿à¤ à¤†à¤µà¤¶à¥à¤¯à¤• à¤¦à¤¸à¥à¤¤à¤¾à¤µà¥‡à¤œà¤¼:
              âœ“ à¤†à¤§à¤¾à¤° à¤•à¤¾à¤°à¥à¤¡
              âœ“ à¤œà¤¼à¤®à¥€à¤¨ à¤•à¤¾ à¤¦à¤¸à¥à¤¤à¤¾à¤µà¥‡à¤œà¤¼
              âœ“ à¤¬à¥ˆà¤‚à¤• à¤–à¤¾à¤¤à¤¾ à¤µà¤¿à¤µà¤°à¤£
              ..."
```

#### Flow 3: Nearby Enrollment Centers
```
User: "à¤¨à¤¿à¤•à¤Ÿà¤¤à¤® à¤†à¤µà¥‡à¤¦à¤¨ à¤•à¥‡à¤‚à¤¦à¥à¤° à¤•à¤¹à¤¾à¤‚ à¤¹à¥ˆ?"
  â”‚
  â”œâ”€â†’ Extract phone number (location implicit in user registration)
  â”‚
  â”œâ”€â†’ Lambda (Locator Service)
  â”‚    â””â”€â†’ Query geolocation from phone + DynamoDB
  â”‚    â””â”€â†’ User location: Lucknow (26.85Â°N, 80.94Â°E)
  â”‚    â”‚
  â”‚    â””â”€â†’ Query DynamoDB: Find centers within 10 km
  â”‚         â””â”€â†’ Filter by scheme availability
  â”‚         â””â”€â†’ Calculate distance using haversine formula
  â”‚         â””â”€â†’ Sort by distance ASC
  â”‚    â”‚
  â”‚    â””â”€â†’ Return top 3 centers with:
  â”‚         â”œâ”€ Name & address
  â”‚         â”œâ”€ Distance (km)
  â”‚         â”œâ”€ Phone & hours
  â”‚         â””â”€ Office in-charge name
  â”‚
  â””â”€â†’ Twilio Send
       â””â”€â†’ SMS or WhatsApp with:
           "ðŸ“ Block Agriculture Office, Malihabad
             à¤ªà¤¤à¤¾: Lucknow, UP 226304
             à¤¦à¥‚à¤°à¥€: 3.2 km
             ðŸ“ž 0522-2671-234
             à¤¸à¤®à¤¯: Mon-Fri, 10 AM - 5 PM"
```

---

## 2. IMPLEMENTATION ARCHITECTURE

### 2.1 AWS Services Used

| Service | Purpose | Configuration |
|---------|---------|----------------|
| **Lambda** | Serverless compute for all logic | 512 MB RAM, 300 sec timeout, Python 3.11 |
| **API Gateway** | HTTP endpoint for webhooks | 100 req/sec rate limit per user |
| **Bedrock** | LLM for NLP (Claude 3) | ap-south-1, max tokens 500 |
| **DynamoDB** | NoSQL for scheme database | On-demand capacity, auto-scaling |
| **RDS PostgreSQL** | Relational for user data | Multi-AZ, encrypted |
| **SNS** | SMS delivery | SMS rate: 1000/min, 10,000/hour |
| **S3** | Document storage | Versioning, encryption, lifecycle |
| **CloudWatch** | Logging & monitoring | Logs retention: 30 days |
| **Twilio** | WhatsApp integration | Webhook endpoint to API Gateway |

### 2.2 Deployment Architecture

```
DEVELOPMENT ENVIRONMENT:
â”œâ”€ Local: Python virtual env + SQLite (for testing)
â”œâ”€ SAM CLI: sam build && sam local start-api
â”œâ”€ AWS SAM Template (template.yaml):
â”‚  â”œâ”€ Lambda functions
â”‚  â”œâ”€ API Gateway setup
â”‚  â”œâ”€ DynamoDB table definitions
â”‚  â””â”€ IAM roles & permissions

STAGING ENVIRONMENT:
â”œâ”€ Dev Stack (AWS CloudFormation)
â”œâ”€ All services replicated
â”œâ”€ Test data in DynamoDB
â”œâ”€ Twilio test credentials

PRODUCTION ENVIRONMENT:
â”œâ”€ Production Stack (AWS CloudFormation)
â”œâ”€ Multi-AZ RDS
â”œâ”€ Reserved capacity for DynamoDB
â”œâ”€ CloudFront CDN for static content
â”œâ”€ WAF for API protection
â”œâ”€ VPC with private subnets for databases
```

### 2.3 CI/CD Pipeline

```
GitHub Commit (main branch)
  â”‚
  â”œâ”€â†’ GitHub Actions Workflow
  â”‚    â”œâ”€ Trigger: push to main
  â”‚    â”œâ”€ Jobs:
  â”‚    â”‚  â”œâ”€ Code quality: Pylint, Black formatter
  â”‚    â”‚  â”œâ”€ Unit tests: pytest + coverage >80%
  â”‚    â”‚  â”œâ”€ Integration tests: Against RDS replica
  â”‚    â”‚  â””â”€ Build SAM: sam build
  â”‚    â”‚
  â”‚    â”œâ”€ Deploy to Staging:
  â”‚    â”‚  â””â”€ sam deploy --stack-name schemes-staging
  â”‚    â”‚
  â”‚    â”œâ”€ Integration tests on Staging
  â”‚    â”‚
  â”‚    â”œâ”€ Approval gate (manual review)
  â”‚    â”‚
  â”‚    â””â”€ Deploy to Production:
  â”‚         â””â”€ sam deploy --stack-name schemes-production
  â”‚
  â””â”€â†’ Health checks post-deployment:
       â”œâ”€ API endpoint responding
       â”œâ”€ DynamoDB queries working
       â”œâ”€ Bedrock API connectivity
       â””â”€ SMS delivery test
```

---

## 3. SECURITY & COMPLIANCE

### 3.1 Data Protection

```
USER PII (Aadhar, Bank Details):
â”œâ”€ Encryption at rest: AES-256 (RDS + S3)
â”œâ”€ Encryption in transit: TLS 1.2+
â”œâ”€ Access control: IAM roles + database-level permissions
â”œâ”€ Masking: Display only last 4 digits of Aadhar in UI
â”œâ”€ Retention: Deleted after 90 days (if user requests)
â””â”€ Audit logging: CloudTrail + CloudWatch

GOVERNMENT DATA (Scheme Info):
â”œâ”€ Read-only access (no modifications via API)
â”œâ”€ Sourced from official government portals
â”œâ”€ Updated quarterly or on ministry notification
â””â”€ Cached for 24 hours (refresh mechanism)
```

### 3.2 Authentication & Authorization

```
USER AUTHENTICATION:
â”œâ”€ Primary: Phone number + OTP (via SMS)
â”œâ”€ Verification: Twilio Verify API
â”œâ”€ Session: JWT token valid for 30 days
â”œâ”€ Logout: Explicit token revocation

API AUTHORIZATION:
â”œâ”€ WhatsApp bot: Verified Twilio webhook signature
â”œâ”€ API clients: API keys + rate limiting
â”œâ”€ Admin dashboard: IAM role-based access
â””â”€ External integrations: OAuth 2.0

LEAST PRIVILEGE:
â”œâ”€ Lambda functions: Specific IAM roles per function
â”œâ”€ Database: Separate users for read/write/admin
â”œâ”€ S3 buckets: Bucket policies + object-level ACLs
â””â”€ RDS: Encryption keys in AWS Secrets Manager
```

### 3.3 Compliance

```
INDIA DATA PROTECTION:
â”œâ”€ MEITY guidelines: Data localization (Mumbai region)
â”œâ”€ RBI guidelines: Encryption standards (AES-256)
â”œâ”€ Privacy: Explicit user consent for SMS/WhatsApp

SECURITY STANDARDS:
â”œâ”€ OWASP Top 10: Input validation, SQL injection prevention
â”œâ”€ AWS Well-Architected: Security, reliability, performance
â”œâ”€ Regular penetration testing: Quarterly third-party audit
â””â”€ Incident response: <4 hour SLA for security issues
```

---

## 4. SCALABILITY & PERFORMANCE

### 4.1 Load Testing Results (Projected)

```
SCENARIO: Peak traffic (5 PM IST, evening rush)

USER LOAD:
â”œâ”€ Concurrent users: 10,000
â”œâ”€ Avg requests/user: 5 per session
â”œâ”€ Total RPS: ~8,333 requests/second

LATENCY (p99):
â”œâ”€ Eligibility check: 2.5 seconds
â”œâ”€ WhatsApp response: 4.5 seconds
â”œâ”€ SMS delivery: <30 seconds (SNS SLA)
â”œâ”€ Database query: <100 ms (DynamoDB)

RESOURCE UTILIZATION:
â”œâ”€ Lambda: 500 concurrent executions (auto-scale to 1,000)
â”œâ”€ DynamoDB: 50,000 RCU, 20,000 WCU (on-demand)
â”œâ”€ RDS: 4-core instance (can scale to 8-core)
â”œâ”€ Data transfer: 1 GB/day (within free tier)

COST ESTIMATE (Monthly at 10K peak users):
â”œâ”€ Lambda: $500
â”œâ”€ DynamoDB: $2,000
â”œâ”€ RDS: $800
â”œâ”€ SNS (SMS): $100
â”œâ”€ Data transfer: $50
â””â”€ TOTAL: ~$3,450/month
```

### 4.2 Caching Strategy

```
WHAT TO CACHE:
â”œâ”€ Scheme database (24-hour TTL) - Rarely changes
â”œâ”€ Enrollment centers (48-hour TTL) - Updated quarterly
â”œâ”€ User preferences (session TTL) - Per user
â””â”€ NLP models (in-memory) - Bedrock handles this

CACHE LAYER: ElastiCache (Redis)
â”œâ”€ Instance: cache.t3.micro (1 GB RAM)
â”œâ”€ Eviction: LRU (least recently used)
â”œâ”€ Backup: Daily snapshots to S3

CACHE HIT RATE: ~85% for scheme queries
```

---

## 5. MONITORING & OBSERVABILITY

### 5.1 CloudWatch Dashboards

```
REAL-TIME METRICS:
â”œâ”€ Request rate (RPS)
â”œâ”€ Error rate (%)
â”œâ”€ Latency (p50, p90, p99)
â”œâ”€ Lambda duration
â”œâ”€ DynamoDB consumed capacity
â””â”€ SMS delivery success rate

ALARMS (Trigger when):
â”œâ”€ Error rate > 1%
â”œâ”€ Latency (p99) > 10 seconds
â”œâ”€ DynamoDB throttling
â”œâ”€ Lambda function errors > 5/min
â””â”€ SMS delivery failure > 5%

DASHBOARDS:
â”œâ”€ Operations (24x7 monitoring)
â”œâ”€ Business metrics (daily usage, conversions)
â””â”€ Financial (cost breakdown by service)
```

### 5.2 Logging Strategy

```
LOG LEVELS:
â”œâ”€ DEBUG: NLP parsing, eligibility matching logic
â”œâ”€ INFO: User interactions, API calls, SMS sent
â”œâ”€ WARN: Failed validations, missing data
â””â”€ ERROR: Exceptions, failed API calls

LOG RETENTION:
â”œâ”€ DEBUG: 7 days
â”œâ”€ INFO: 30 days
â”œâ”€ ERROR: 90 days (compliance)

STRUCTURED LOGGING:
{
  "timestamp": "2026-01-25T10:30:00Z",
  "userId": "9876543210",
  "action": "eligibility_check",
  "input": {"income": 250000, "occupation": "farmer"},
  "result": ["PM-KISAN", "AYUSHMAN"],
  "latency_ms": 245,
  "statusCode": 200
}
```

---

## 6. DEPLOYMENT CHECKLIST

### Pre-Launch (72 hours before go-live)

- [ ] DynamoDB: Load all 50+ schemes
- [ ] RDS: Create user tables, test migration scripts
- [ ] Bedrock: Test Claude API with 1000 sample messages
- [ ] Twilio: Verify webhook certificates, test message flow
- [ ] SMS: Test SNS delivery with 100 test messages
- [ ] Security: Run OWASP dependency check, update all packages
- [ ] Monitoring: Set up CloudWatch alarms, dashboards
- [ ] Load testing: Simulate 1000 concurrent users
- [ ] Failover testing: Test RDS failover, Lambda error handling
- [ ] Documentation: Runbooks for on-call engineer

### Launch Day

- [ ] Database backups created
- [ ] Monitoring team on standby
- [ ] Soft launch: 100 beta testers
- [ ] Monitor error rates for 1 hour
- [ ] Scale to 1,000 users if stable
- [ ] Gradual ramp-up to 10,000 users
- [ ] Business metrics tracking active
- [ ] Support hotline staffed

### Post-Launch (Week 1)

- [ ] Daily team sync on metrics
- [ ] Review and fix any bugs
- [ ] Collect user feedback
- [ ] Performance optimization
- [ ] Security audit follow-up
- [ ] Plan Phase 2 features

---

## 7. DISASTER RECOVERY

### 7.1 RTO/RPO Targets

```
RTO (Recovery Time Objective): 1 hour
RPO (Recovery Point Objective): 15 minutes

FAILURE SCENARIOS:
â”œâ”€ Database corruption
â”‚  â””â”€ Recovery: Restore from hourly snapshot
â”‚
â”œâ”€ Lambda function error
â”‚  â””â”€ Recovery: Automatic rollback to previous version
â”‚
â”œâ”€ Twilio outage
â”‚  â””â”€ Recovery: Failover to SMS-only mode
â”‚
â”œâ”€ Bedrock unavailable
â”‚  â””â”€ Recovery: Use rule-based NLP fallback
â”‚
â””â”€ Complete region failure
   â””â”€ Recovery: Failover to secondary region (manual)
```

### 7.2 Backup Strategy

```
RDS BACKUPS:
â”œâ”€ Automated daily snapshots (30-day retention)
â”œâ”€ Automated transaction logs (15-minute granularity)
â”œâ”€ Manual snapshots before major deployments

DynamoDB BACKUPS:
â”œâ”€ Point-in-time recovery enabled (35-day window)
â”œâ”€ Daily exports to S3 (Parquet format)

S3 BACKUPS:
â”œâ”€ Versioning enabled
â”œâ”€ Cross-region replication to secondary bucket
â”œâ”€ Lifecycle: Archive to Glacier after 90 days

TESTING:
â”œâ”€ Monthly restore test from backup
â”œâ”€ RTO/RPO validation
â””â”€ Document recovery procedures
```

---

**End of Technical Design Document**
